<sect1 id="graph-per-aspect">
  <title>Graph Per Aspect</title>
  <para> 
   <emphasis>How can we avoid contention around updates to a single graph when applying the <link linkend="graph-per-resource">Graph Per Resource</link> pattern?</emphasis>
  </para>

  <sect2><title>Context</title>
  <para>For some applications the entire description of a resource might be maintained by a single authority, e.g. the data might all derive from a single data conversion or be managed by a single editing interface. However in some applications data about a single resource might be contributed in different ways. One example might be a VoiD description for a dataset. A dataset description may consist of a mixture of hand-authored information -- e.g. a title, description, and example resources -- plus some statistics derived from the dataset itself, e.g. size and class partitions. An administrator might update the descriptive aspects while the rest is updated asynchronously by a background application that analyses the dataset.</para>
  <para>Multiple applications writing to the same graph could lead to contention for system resources or the need to implement complex locking behaviour.</para>
  </sect2>

  <sect2><title>Solution</title>
  <para>Apply a combination of the <link linkend="graph-per-resource">Graph Per Resource</link> and <link linkend="graph-per-source">Graph Per Source</link> patterns and factor out the different aspects of a resources description into separate graphs. Use a <link linkend="union-graph">Union Graph</link> to collate the different aspects of the description of a resource into a single view.</para>
  </sect2>

  <sect2><title>Example(s)</title>
  <para>A content management application stores information about articles. This includes descriptive metadata about the articles as well as pointers to the content. Content metadata will be manually managed by users. In the background two additional processes will be carrying out additional tasks. One will be retrieving the content of the article to perform text mining, resulting in machine-tagging of subjects in the article. The second will be harvesting related links from the rest of the system and the web. The "aspect graphs" are created: one for the core metadata, one for the tags and one for the links:</para>
	<programlisting>
	<![CDATA[
#core description of a resource; provided by user
<http://data.example.org/graphs/core/document/1> {
	<http://example.org/document/1> dct:title "Bath in the Summertime".
}    	
#tags; maintained by process 1.
<http://data.example.org/graphs/tags/document/1> {
	<http://example.org/document/1> dc:subject "Bath".
	<http://example.org/document/1> dc:subject "Travel".
}    	
#related links; maintained by process 2.
<http://data.example.org/graphs/links/document/1> {
	<http://example.org/document/1> dct:related <http://travel.example.org/doc/bath>.
}    	
#System metadata graph, listing topic of each graph
<http://data.example.org/graphs> { 
	<http://data.example.org/graphs/core/document/1> foaf:primaryTopic <http://example.org/document/1>.
	<http://data.example.org/graphs/tags/document/1> foaf:primaryTopic <http://example.org/document/1>.
	<http://data.example.org/graphs/links/document/1> foaf:primaryTopic <http://example.org/document/1>.
}
]]></programlisting> 
  <para>As the above example illustrates, graph URIs for the different aspects of a resources description can by generated by using <link linkend="patterned-uris">Patterned URIs</link>. A fourth graph, covering system-wide metadata is also maintained. This graph lists the <code>foaf:primaryTopic</code> of each graph, allowing applications to discover which graphs relate to a specific resource.</para>
   <para>
	An application consuming this data could rely on either a system default <link linkend="union-graph">Union Graph</link> to provide a complete view of a resource. Partial views might address individual named graphs. Using a CONSTRUCT query it is also possible to construct a view of a resource using just those graphs referenced in the system metadata graph:</para>
	<programlisting>
	<![CDATA[
CONSTRUCT { ?s ?p ?o. }
WHERE {
 GRAPH <http://data.example.org/graphs> {
   	  ?graph foaf:primaryTopic <http://example.org/document/1>.
  }
 GRAPH ?graph { ?s ?p ?o. }
}
]]></programlisting> 
  </sect2>

  <sect2><title>Discussion</title>
  <para>Named graphs provide flexibility in how to organise an RDF data store. In some cases storage is oriented towards the sources of data, in others around individual resources. The Graph Per Aspect pattern provides a combination of those features that allows for very fine-grained graph management. The description of each resource is divided over a number of graphs, each of which is contributed to the system by a different source or application component.</para>
  <para>As with the other named graph patterns reliance is made on the <link linkend="union-graph">Union Graph</link> pattern to bring together the description of a resource into a single consistent view.</para>
  <para>Separating out aspects of resource description into different graphs also provides a way to shard a dataset. Different aspects might be stored in different triple stores across a network. These are then brought together in the application for building a user interface. With knowledge of how graphs are partitioned across the network, as well as which graphs contain which statements, an application can use <link linkend="parallel-retrieval">Parallel Retrieval</link> to synthesis a local working copy of a resource's description. This aggregation could happen within a server component or on the client-side</para>
   <para>The small, focused graphs created by use of this pattern and, more generally, by the <link linkend="graph-per-resource">Graph Per Resource</link> pattern are very amenable for delivery to mobile &amp; web clients for local processing. By separating out the different aspects of a resource into graphs that are likely to change with differing frequencies, caching can be made much more efficient.</para>
  </sect2>

  <sect2><title>Related</title>
  <itemizedlist>
  <listitem><link linkend="named-graphs">Named Graph</link></listitem>
  <listitem><link linkend="graph-annotation">Graph Annotation</link></listitem>
  <listitem><link linkend="graph-per-source">Graph Per Source</link></listitem>
  <listitem><link linkend="graph-per-aspect">Graph Per Aspect</link></listitem>
  </itemizedlist>
  </sect2>

  <sect2><title>Further Reading</title>
  <itemizedlist>
  <listitem><ulink linkend="http://eprints.cs.univie.ac.at/2910/">Keep Your Triples Together: Modeling a RESTtful, Layered Linked Data Store</ulink></listitem>
  </itemizedlist>
  </sect2>
</sect1>

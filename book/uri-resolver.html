<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>URI Resolver</title><link rel="stylesheet" type="text/css" href="../css/style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Linked Data Patterns" /><link rel="up" href="application-patterns.html" title="Chapter 6. Application Patterns" /><link rel="prev" href="transformation-query.html" title="Transformation Query" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">URI Resolver</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="transformation-query.html">Prev</a> </td><th width="60%" align="center">Chapter 6. Application Patterns</th><td width="20%" align="right"> </td></tr></table><hr /></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="uri-resolver"></a>URI Resolver</h2></div></div></div><p> 
   <span class="emphasis"><em>How can we customize the application behaviour associated with resolving (de-referencing) a URI into RDF statements?</em></span>
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm2004"></a>Context</h3></div></div></div><p>Linked Data applications typically acquire additional relevant data by adopting <a class="link" href="follow-your-nose.html" title="Follow Your Nose">Follow Your Nose</a> behaviour: any URI in a graph may be assumed to be de-referencable to obtain additional data.</p><p>However in practice simple de-referencing, i.e. performing a GET request on a URI, is not always desirable. For example:
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">An mobile application may need to work in an off-line mode where remote data is not available</li><li class="listitem">Continuous testing scenarios may need to rely on predictable data for driving test assertions and, in addition, may need to be executable in a self-contained environment without use of network services</li><li class="listitem">Security constraints may require network requests to be routed via an intermediary service</li><li class="listitem">A local mirror may be available which can provide a better quality of service</li><li class="listitem">A remote service may be intermittently or completely unavailable, requiring a local mirror to be substituted on either a temporary or permanent basis</li></ul></div><p>
  </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm2015"></a>Solution</h3></div></div></div><p>Application code should address de-referencing requests to URI resolver. Broadly, a URI resolver is a function that maps from a URI to a stream from which RDF triples can be consumed. A URI resolver might consist of an application component or could be deployed as a network addressable service (i.e. a proxy server).</p><p>Application code should defer to the URI resolver in order to source RDF statements and provide configuration options to specify which URI resolver (e.g. implementation or service location) should be used. Simple de-referencing behaviour may still be used as fallback behaviour if no URI resolver is available.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm2019"></a>Example(s)</h3></div></div></div><p>A Linked Data browser loads and displays resources as directed by user behaviour, e.g. clicking on links in the user interface. A user selects to view a resource. When a user requests that the browser displays a resource, <code class="code">http://example.org/person/1</code>, instead of performing a GET request on the resource the browser invokes a pre-configured URI resolver to retrieve the description of the resource.</p><p>The URI resolver has been set up to direct requests matching a pattern of <code class="code">http://example.org/*</code> to a local triple store that contains a mirror of the remote data. However when the user visits <code class="code">http://other.example.org/document/123</code> the URI resolver does not have any prior knowledge of the resource and falls back to a simple GET request on the resource URI.</p><p>In neither case does the browser (or the user) need to know how the description was actually retrieved.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm2027"></a>Discussion</h3></div></div></div><p>Adding some extra indirection around the de-referencing of URIs into RDF statements provides some much needed flexibility when dealing with network issues such as intermittently available connections; unreliable remote services; and security constraints. Applications that support the configuration of URI resolvers provide options for customising and optimising application behaviour based on local requirements.</p><p>URI resolvers are not a new concept and have been used in many different systems. SGML and XML processing pipelines typically support URI resolver components to allow resources to be cached locally or even bundled with an application. More broadly, HTTP proxy servers fulfill the role for general web requests.</p><p>The indirection offered by URI resolvers make them an ideal location in which to provide additional behaviour. For example all of the following can be implemented using a URI resolver component:
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Caching of RDF descriptions as they are retrieved, e.g. in an in-memory, file system, or document store</li><li class="listitem">Substitution of a local mirror of the data in preference for the remote version</li><li class="listitem">Substitution of a local mirror of the data in preference for the remote version, but only where the remote service is unavailable</li><li class="listitem">Serving of a fixed response, regardless of URI (e.g. to support testing scenarios)</li><li class="listitem">Retrieval of both the remote description of a resource plus local <a class="link" href="annotation.html" title="Annotation">annotations</a> to mix public and private data</li><li class="listitem"><a class="link" href="parallel-retrieval.html" title="Parallel Retrieval">parallel retrieval</a> of the description of a resource that is spread across any combination of local or remote locations</li><li class="listitem">Provision of reasoning over retrieved data to augment data against a vocabulary</li><li class="listitem">Provision of support for resolution of non-HTTP URI schemes</li><li class="listitem">On-demand conversion of non-RDF data into RDF statements</li></ul></div><p>
</p><p>With suitable configuration, URI resolvers can potentially be chained together to create a de-referencing pipeline that can deliver some complex application behaviours with a simple framework.</p><p>There are some Linked Data applications that provide URI resolver services, this includes generic Linked Data browsers. At their simplest the browsers simply provide additional HTML presentation of retrieved data. But in some cases the retrieved data is both directly accessible (i.e. the service acts as a proxy) and may be supplemented with local caches, annotation, or inferencing, as outlined above. To support de-referencing typically use a <a class="link" href="rebased-uri.html" title="Rebased URI">Rebased URI</a></p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm2047"></a>Related</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a class="link" href="follow-your-nose.html" title="Follow Your Nose">Follow Your Nose</a></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm2052"></a>Further Reading</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a class="ulink" href="" target="_top">Diverted URI pattern</a></li><li class="listitem"><a class="ulink" href="" target="_top">The Jena FileManager and LocationMapper</a></li><li class="listitem"><a class="ulink" href="" target="_top">Entity management in XML applications</a></li></ul></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="transformation-query.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="application-patterns.html">Up</a></td><td width="40%" align="right"> </td></tr><tr><td width="40%" align="left" valign="top">Transformation Query </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
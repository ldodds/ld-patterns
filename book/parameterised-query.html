<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Parameterised Query</title><link rel="stylesheet" type="text/css" href="../css/style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Linked Data Patterns" /><link rel="up" href="application-patterns.html" title="Chapter 6. Application Patterns" /><link rel="prev" href="parallel-retrieval.html" title="Parallel Retrieval" /><link rel="next" href="resource-caching.html" title="Resource Caching" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Parameterised Query</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="parallel-retrieval.html">Prev</a> </td><th width="60%" align="center">Chapter 6. Application Patterns</th><td width="20%" align="right"> <a accesskey="n" href="resource-caching.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="parameterised-query"></a>Parameterised Query</h2></div></div></div><p> 
   <span class="emphasis"><em>How to avoid continual regeneration and reparsing of SPARQL queries that differ only in a few bound variables?</em></span>
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm1818"></a>Context</h3></div></div></div><p>Many applications continually execute a small number of queries which differ only in terms of a few parameters. For example generating a <a class="link" href="bounded-description.html" title="Bounded Description">Bounded Description</a> of a resource might involve a standard query that varies only by the resource URI being referenced. Other queries might vary based on date ranges, page offsets, etc. Re-generating queries as text strings can be fiddly and makes for messy application code. This is particularly true when the query then needs to be serialised and submitted over the SPARQL protocol: URL encoding issues can easily cause problems. In addition a query engine incurs extra overhead when repeatedly parsing the same query.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm1822"></a>Solution</h3></div></div></div><p>Define each repeated query as as query template which can be parsed once by the query engine. The query should define variables for those aspects of the query that might vary. The variables can then be bound to the query before execution. Supplying the values for these parameters will typically involve an engine specific API call.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm1825"></a>Example(s)</h3></div></div></div><p>Apache Jena uses a <code class="code">QueryExecutionFactory</code> to support creation of queries. Query objects can be pre-compiled. An initial set of bindings for a query can be provided in order to <a class="ulink" href="" target="_top">create a specific QueryExecution</a>. These initial bindings are simply a map from variable name to value.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm1830"></a>Discussion</h3></div></div></div><p>This pattern is well understood in the SQL database world: Prepared Statements have been in use for many years. SPARQL processors are now starting to add similar features, which simplifies working with queries from application code.</p><p>At present the SPARQL Protocol does not support specification of initial bindings as additional query string parameters. However some Linked Data publishing platforms have added support for parameterised queries, as extensions to the core protocol, allowing additional query parameters to be automatically injected into the query prior to execution. This makes it simpler for users to share queries and adjust their parameters.</p><p>SPARQL 1.1 provides <a class="ulink" href="" target="_top">a <code class="code">VALUES</code> keyword</a> which can be used to declare that certain variables should be injected into a graph pattern. This was added primarily to support federated query use cases, but can also be used to support some parameterisation of queries.</p><p>A map of named-value pairs which describe some initial query bindings can also be interpolated directly into a query by looking for appropriately named query variables. This interpolation has been done in several ways:
	</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Using some additional custom syntax to mark up the variable, e.g. <code class="code">%{var}</code>. This means that the query is no longer valid SPARQL into variables have been substituted</li><li class="listitem">By using the fact that SPARQL provides two naming syntaxes for variables, and defining <code class="code">$var</code> to be those that are bound before execution and <code class="code">?var</code> those that are bound during execution (or vice versa). This relies on local convention.</li><li class="listitem">By binding any query variable using any valid SPARQL syntax. The downside to this option is that additional external context is required to identify those variables that must be bound prior to execution. The other options allow these to be identified from just the query itself, although in practice it is often useful to be able to know the expected type, format or legal values for a parameter which will require additional configuration anyway.</li></ul></div><p>Parameterised Queries are a core feature of the <a class="link" href="named-query.html" title="Named Query">Named Query</a> pattern.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm1847"></a>Related</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a class="link" href="named-query.html" title="Named Query">Named Query</a></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm1852"></a>Further Reading</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a class="ulink" href="" target="_top">SPARQL 1.1. VALUES: Providing inline data</a></li></ul></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="parallel-retrieval.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="application-patterns.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="resource-caching.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Parallel Retrieval </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Resource Caching</td></tr></table></div></body></html>
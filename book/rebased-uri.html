<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Rebased URI</title><link rel="stylesheet" type="text/css" href="../css/style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Linked Data Patterns" /><link rel="up" href="identifier-patterns.html" title="Chapter 2. Identifier Patterns" /><link rel="prev" href="proxy-uris.html" title="Proxy URIs" /><link rel="next" href="shared-keys.html" title="Shared Keys" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Rebased URI</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="proxy-uris.html">Prev</a> </td><th width="60%" align="center">Chapter 2. Identifier Patterns</th><td width="20%" align="right"> <a accesskey="n" href="shared-keys.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="rebased-uri"></a>Rebased URI</h2></div></div></div><p> 
   <span class="emphasis"><em>How can we construct one URI based on another?</em></span>
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm236"></a>Context</h3></div></div></div><p>Sometimes when generating a <a class="link" href="patterned-uris.html" title="Patterned URIs">Patterned URI</a> the key that we have for as <a class="link" href="url-slug.html" title="URL Slug">URL Slug</a> is not a simple literal value, but instead another URI. For example this can occur when generating a new Named Graph URI for a resource, or when defining a service URL for a <a class="link" href="uri-resolver.html" title="URI Resolver">URI Resolver</a>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm242"></a>Solution</h3></div></div></div><p>Rewrite the original URI to use a new, predictable base URI using on of the options described below.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm245"></a>Example(s)</h3></div></div></div><p>An application needs to generate a new Named Graph URI for a resource URI of <code class="code">http://example.org/document/1</code>. The application uses a regular expression to rewrite the original URI to a new base, e.g. <code class="code">http://graphs.example.org/document/1</code>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm250"></a>Discussion</h3></div></div></div><p>URL rewriting is a common feature of all web servers and most web frameworks. Rewriting is normally carried out using regular expressions to match and replace portions of the original URI with some standard replacement text.</p><p>URL rewriting is used in several Linked Data services in order to create new URLs. This is typically to support <a class="link" href="uri-resolver.html" title="URI Resolver">URI resolution</a> for remote (RDF) resources.</p><p>Several different approaches seem to be in use. The following examples all show a rewrite for this URI: <code class="code">http://example.org/document/1</code>. Each example notes an example service that uses the approach:
	</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="emphasis"><em>Simple Prefixing</em></span> (URIBurner): <code class="code">http://service.example.com/resolve/http://example.org/document/1</code>. The original URI is simply appended to a new base URL. Has the advantage of working with any protocol.</li><li class="listitem"><span class="emphasis"><em>Prefixing, No Protocol</em></span> (Triplr): <code class="code">http://service.example.com/resolve/example.org/document/1</code>. The original URI is simply appended to a new base URL after first removing the protocol (e.g. "http://"). Server will need to assume the <code class="code">http</code> protocol if de-referencing the URI or reversing the rewrite.</li><li class="listitem"><span class="emphasis"><em>Prefixing, With Delimiter</em></span> (Callimachus): <code class="code">http://service.example.com/resolve;http://example.org/document/1</code>. The original URI is simply appended to a new base URL which ends with a semi-colon.</li><li class="listitem"><span class="emphasis"><em>Prefixing, As Parameter</em></span>  (SPARQL Graph Protocol): <code class="code">http://service.example.com/resolve?uri=http://example.org/document/1</code>. The original URI is simply appended to a new base URL as a query string parameter.</li><li class="listitem"><span class="emphasis"><em>Rewritten Authority</em></span>: <code class="code">http://data.example.org/document/1</code>. The authority component of the URI is rewritten to create a new base URI. This approach might lead to URI clashes unless the input URIs have a predictable structure.</li></ul></div><p>
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm274"></a>Related</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a class="link" href="uri-resolver.html" title="URI Resolver">URI resolver</a></li></ul></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="proxy-uris.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="identifier-patterns.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="shared-keys.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Proxy URIs </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Shared Keys</td></tr></table></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 3. Modelling Patterns</title><link rel="stylesheet" href="../css/style.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /><meta name="description" content="Creating a model of some domain for publishing data as Linked Data is, fundamentally, no different to any other form of modelling exercise: we need to understand the core entities and their attributes, including their relationships to one another. RDF has a core model that is based on the decared old Entity-Attribute-Value (EAV) approach that underpins many different information management approaches and technologies. What is different and new for many people is the context in which that modelling is carried out. When we are creating an Entity-Relationship (ER) or Object-Oriented model we are typically doing so in order to support the needs of a particular application. We have some idea about what data the application needs to store and we tailor the model accordingly. We also typically optimise the model for the needs of that application. In particular, when translating a logical ER into a physical database schema, we often need to introduce new entities, e.g. to capture many-many relationships in order to be able to express the model within the restrictions imposed by a relational database. In a Linked Data context we approach a modelling exercise in a different way. Firstly we may be able to avoid the exercise completely. Using RDF Schema and OWL it is possible to share vocabularies (or ontologies, or schemas, whatever your prefered term) on the web, just as we share data. This means that communities of interest can collaborate around a data model and then extend it where necessary. With semantic web technologies we can better crowd-source and share our data models. It is often the case that a combination of existing vocabularies will adequately cover a domain. Where there is a short-fall we can define small extensions, e.g. new properties or types, that extend the model for our purposes. The second key difference is that we focus on modelling the domain itself and set aside the immediate needs of the application. By focusing on the model rather than the application, we are more likely to be able to extend and enrich the model at a later date. Thinking about the entities and their relationships, rather than our application code, results in a stronger model. And one that may be more likely to be of use to others. Of course a model must ultimately support the kinds of data we want to capture or manipulate in our application. The ability to populate and query a model is a good test of its fit for purpose, but application requirements alone shouldn't guide our modelling. This is not the same as saying that all modelling must be done up front. Modelling for Linked Data can be agile and iterative. We should just take care to think about the likely areas of extension, as the Link Not Label pattern illustrates. Thirdly, and finally, the other important way in which RDF modelling differs from other approaches is that there is no separate physical data model: the logical model is exactly how our data is stored. An RDF triple store is &quot;schema-free&quot; in the sense that we don't have to define the physical layout (e.g. tables, columns) of our database. Any RDF triple store can store any RDF data expressed using any RDF vocabulary. This makes RDF very amenable for rapid, iterative application development. Importantly it also means that everyone involved in a project team is working off the same domain model; the same mental model of how the resources in a dataset are described and how they relate to one another. This chapter introduces a number of RDF modelling patterns that are useful in a variety of different use cases. Several of the patterns are really illustrations of how to use particular features of RDF, e.g. annotation of literals with data types or languages. We've included these within the overall patterns collection as we feel that presenting them as solutions to specific questions, e.g. &quot;How can internationalized text be expressed in RDF?&quot; may help address what are frequently asked questions by new users." /><link rel="home" href="index.html" title="Linked Data Patterns" /><link rel="up" href="index.html" title="Linked Data Patterns" /><link rel="prev" href="url-slug.html" title="URL Slug" /><link rel="next" href="custom-datatype.html" title="Custom Datatype" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 3. Modelling Patterns</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="url-slug.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="custom-datatype.html">Next</a></td></tr></table><hr /></div><div class="chapter" title="Chapter 3. Modelling Patterns"><div class="titlepage"><div><div><h2 class="title"><a id="modelling-patterns"></a>Chapter 3. Modelling Patterns</h2></div><div><div class="abstract" title="Abstract"><p class="title"><b>Abstract</b></p><p>Creating a model of some domain for publishing data as Linked Data is, fundamentally, no different to any other form of modelling exercise: we need to understand the core entities and their attributes, including their relationships to one another. RDF has a core model that is based on the decared old Entity-Attribute-Value (EAV) approach that underpins many different information management approaches and technologies. What is different and new for many people is the context in which that modelling is carried out.</p><p>When we are creating an Entity-Relationship (ER) or Object-Oriented model we are typically doing so in order to support the needs of a particular application. We have some idea about what data the application needs to store and we tailor the model accordingly. We also typically optimise the model for the needs of that application. In particular, when translating a logical ER into a physical database schema, we often need to introduce new entities, e.g. to capture many-many relationships in order to be able to express the model within the restrictions imposed by a relational database.</p><p>In a Linked Data context we approach a modelling exercise in a different way.</p><p>Firstly we may be able to avoid the exercise completely. Using RDF Schema and OWL it is possible to share vocabularies (or ontologies, or schemas, whatever your prefered term) on the web, just as we share data. This means that communities of interest can collaborate around a data model and then extend it where necessary. With semantic web technologies we can better crowd-source and share our data models.</p><p>It is often the case that a combination of existing vocabularies will adequately cover a domain. Where there is a short-fall we can define small extensions, e.g. new properties or types, that extend the model for our purposes.</p><p>The second key difference is that we focus on modelling the domain itself and set aside the immediate needs of the application. By focusing on the model rather than the application, we are more likely to be able to extend and enrich the model at a later date. Thinking about the entities and their relationships, rather than our application code, results in a stronger model. And one that may be more likely to be of use to others.</p><p>Of course a model must ultimately support the kinds of data we want to capture or manipulate in our application. The ability to populate and query a model is a good test of its fit for purpose, but application requirements alone shouldn't guide our modelling.</p><p>This is not the same as saying that all modelling must be done up front. Modelling for Linked Data can be agile and iterative. We should just take care to think about the likely areas of extension, as the <a class="link" href="link-not-label.html" title="Link Not Label">Link Not Label</a> pattern illustrates.</p><p>Thirdly, and finally, the other important way in which RDF modelling differs from other approaches is that there is no separate physical data model: the logical model is exactly how our data is stored. An RDF triple store is "schema-free" in the sense that we don't have to define the physical layout (e.g. tables, columns) of our database. Any RDF triple store can store any RDF data expressed using any RDF vocabulary.</p><p>This makes RDF very amenable for rapid, iterative application development. Importantly it also means that everyone involved in a project team is working off the same domain model; the same mental model of how the resources in a dataset are described and how they relate to one another.</p><p>This chapter introduces a number of RDF modelling patterns that are useful in a variety of different use cases. Several of the patterns are really illustrations of how to use particular features of RDF, e.g. annotation of literals with <a class="link" href="typed-literal.html" title="Typed Literal">data types</a> or <a class="link" href="multi-lingual-literal.html" title="Multi-Lingual Literal">languages</a>. We've included these within the overall patterns collection as we feel that presenting them as solutions to specific questions, e.g. "How can internationalized text be expressed in RDF?" may help address what are frequently asked questions by new users.</p></div></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="custom-datatype.html">Custom Datatype</a></span></dt><dt><span class="sect1"><a href="index-resources.html">Index Resources</a></span></dt><dt><span class="sect1"><a href="label-everything.html">Label Everything</a></span></dt><dt><span class="sect1"><a href="link-not-label.html">Link Not Label</a></span></dt><dt><span class="sect1"><a href="multi-lingual-literal.html">Multi-Lingual Literal</a></span></dt><dt><span class="sect1"><a href="nary-relation.html">N-Ary Relation</a></span></dt><dt><span class="sect1"><a href="ordered-list.html">Ordered List</a></span></dt><dt><span class="sect1"><a href="ordering-relation.html">Ordering Relation</a></span></dt><dt><span class="sect1"><a href="preferred-label.html">Preferred Label</a></span></dt><dt><span class="sect1"><a href="qualified-relation.html">Qualified Relation</a></span></dt><dt><span class="sect1"><a href="reified-statement.html">Reified Statement</a></span></dt><dt><span class="sect1"><a href="repeated-property.html">Repeated Property</a></span></dt><dt><span class="sect1"><a href="topic-relation.html">Topic Relation</a></span></dt><dt><span class="sect1"><a href="typed-literal.html">Typed Literal</a></span></dt></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="url-slug.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="custom-datatype.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">URL Slug </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Custom Datatype</td></tr></table></div></body></html>
